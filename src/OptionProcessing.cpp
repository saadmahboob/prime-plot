#include "OptionProcessing.hpp"



namespace OptionProcessing
{
	std::string									programName;
	Action										action = Action::Invalid;
	int											base = 10;
	std::string									baseAlphabet = "0123456789";
	int											baseAlphabetPending = 0;
	long										limit = -1;
	std::ofstream								outputFile;
	std::streambuf*								outputBuf = std::cout.rdbuf();
	std::ifstream								primeInput;
	int											primeInputBeginIndex = 0;
	int											primeInputBase = 10;
	std::string									primeInputBaseAlphabet = "0123456789";
	int											rowBegin = 0, rowInterval = 1;
	int											columnBegin = 0, columnInterval = 1;
	bool										enableAsciiArtColors = false;
	//int										numGeneratorThreads = 1;
	int											terminalWidth = -1, terminalHeight = -1;
	#ifdef __unix__
	bool										terminalSizeOptional = true;
	#else
	bool										terminalSizeOptional = false;
	#endif
}

void OptionProcessing::printUsage()
{
	std::cout << "Usage: ./prime-plot [options]\n"																	//no line is longer than 80 characters
			"Options:\n"
			"  --help              Displays this information\n"
			"  --action=<action>   Specify the action the program will execute.\n"
			"                      These are the supported values for <action>:\n"
			"                        generate\n"
			"                            Generate all primes up to the specified limit in\n"
			"                            the specified base and output them.\n"
			"                        last-digit-ascii-art\n"
			"                            Check all primes up to the specified limit in the\n"
			"                            specified base for their last digit and output\n"
			"                            the number of combinations for consecutive primes\n"
			"                            in an ascii art table. The left column will\n"
			"                            contain the first value of the combination (the\n"
			"                            'from' number), the top row will contain the\n"
			"                            second value (the 'to' number). Note that all\n"
			"                            information the table contains will be in base\n"
			"                            10.\n"
			"                        last-digit-csv\n"
			"                            Like last-digit-ascii-art, but uses comma\n"
			"                            separated values for output and will not contain\n"
			"                            any headers.\n"
			"                        last-digit-csv-with-headers\n"
			"                            Like last-digit-csv, but output will include\n"
			"                            headers embedded into the 'useful' output.\n"
			"                        diagonal-averages\n"
			"                            Output the averages of all diagonals, from bottom\n"
			"                            left to top right, of the table generated by any\n"
			"                            last-digit-* action. E.g. when --base=3, the rows\n"
			"                            (with the 'from' numbers) are from 0 to 2, the\n"
			"                            columns (with the 'to' numbers) have the same\n"
			"                            range. The first number output by this action will\n"
			"                            then be the 2-->0 number. The second will be the\n"
			"                            average of the 2-->1 and 1-->0 numbers. The third\n"
			"                            will be the average of the 2-->2, 1-->1 and 0-->0\n"
			"                            numbers and so on. Eventually, this will lead to\n"
			"                            2*base-1 output numbers.\n"
			"                      This option is required.\n"
			"  --base=<base>[,<alphabet>] Set the base to use for primes during processing.\n"
			"                      Note that this option will not change the base of the\n"
			"                      number of combination output by last-digit-* actions.\n"
			"                      However, it does change the base of primes output by\n"
			"                      the generate action. The alphabet is optional with a\n"
			"                      default value of 0123456789, but if it is given, it has\n"
			"                      to be a string that is 'base' characters long and that\n"
			"                      contains the alphabet used for outputting numbers. As\n"
			"                      an example, you may use\n"
			"                      --base=26,ABCDEFGHIJKLMNOPQRSTUVWXYZ if you want to\n"
			"                      output the primes in base 26 with letters as numbers.\n"
			"                      If this option is not given, base 10 with 0123456789 as\n"
			"                      alphabet is used.\n"
			"  --limit=<limit>     Set the limit for the number of primes to test (not the\n"
			"                      primes themselves!). When the value has a K, M, G or T\n"
			"                      prefix, it will be multiplied by a thousand, a million,\n"
			"                      a billion or a trillion, respectively. This option is\n"
			"                      required.\n"
			"  --output=<file>     Sets the filename of the file used for output. If this\n"
			"                      option is not given, the standard output is used.\n"
			"  --prime-input=<file>[,<begin_index>] When a valid file is specified for\n"
			"                      this option, the primes needed for the desired action\n"
			"                      will be read from it (for 'generate' as well). If\n"
			"                      this option is not given, all of the needed primes\n"
			"                      will be generated again at runtime. When a value for\n"
			"                      'limit' is specified and the specified input file\n"
			"                      does not contain all needed primes, the missing ones\n"
			"                      will be generated as well. The begin index is not\n"
			"                      necessary for this option (its default value is 0,\n"
			"                      because the first line is expected to contain 2), but\n"
			"                      if it is given, it specifies the index of the first\n"
			"                      prime in the file (zero-based), e.g. the begin index\n"
			"                      for this option should be 1233 if the first line in\n"
			"                      the file contains 10061.\n"
			"  --prime-input-base=<base>[,<alphabet] Expects the same parameters as\n"
			"                      --base, but controls the base of the primes read from\n"
			"                      the file specifies by --prime-input. If this option is\n"
			"                      not given, base 10 with 0123456789 as alphabet is used.\n"
			"  --row-interval=i,j  Only output every jth row, beginning at row i. The row\n"
			"                      numbers are zero-based. E.g. when this option's value\n"
			"                      is 2,3, the program will output the rows #2, #5, #8\n"
			"                      and so on. The default value for this option is 0,1.\n"
			"  --column-interval=i,j Works just like --row-interval, just for columns. The\n"
			"                      default value for this option is 0,1 as well.\n"
			"  --enable-ascii-art-colors=y/n If this option's value begins with 'y' or '1',\n"
			"                      and --action=last-digit-ascii-art, the background of\n"
			"                      the numbers in the table body will be colored. If a\n"
			"                      value is the highest in the table, it will be colored\n"
			"                      in bright red, linearly going down to white, i.e. 0.\n"
			"                      Note that ANSI escape sequences are used to color the\n"
			"                      background in true color (ISO-8613-3), your terminal\n"
			"                      may not support this. Recent versions of Xterm, GNOME\n"
			"                      terminal, KDE's Konsole and the OS X terminal should\n"
			"                      support this, others may or may not, and Windows's\n"
			"                      CMD does not at all. When the output is redirected\n"
			"                      to a file using --output, this option is ignored and\n"
			"                      no colors are used. By default, this option is disabled.\n";
}

void OptionProcessing::process(int argc, char** argv)
{
	std::vector<std::string> args;
	std::string currPrefix, currSuffix;

	programName = argv[0];
	for(int i=1; i<argc; i++)
		args.push_back(argv[i]);
	
	if(args.size() == 0)
	{
		std::cout << "This program needs command line parameters, try " << programName << " --help\n";
		std::exit(0);
	}
	if(std::find(args.begin(), args.end(), "--help") != args.end())
	{
		printUsage();
		std::exit(0);
	}
	
	for(auto& a : args)
	{
		if(a.find("=") == std::string::npos)
		{
			std::cerr << "error: malformed option: " << a << "\n";
			std::exit(1);
		}
		
		currPrefix = a.substr(0, a.find("="));
		currSuffix = a.substr(a.find("=") + 1, a.size() - 1);
		if(currPrefix == "--action")
		{
			if(currSuffix == "generate")
				action = Action::Generate;
			else if(currSuffix == "last-digit-ascii-art")
				action = Action::LastDigitAsciiArt;
			else if(currSuffix == "last-digit-csv")
				action = Action::LastDigitCsv;
			else if(currSuffix == "last-digit-csv-with-headers")
				action = Action::LastDigitCsvWithHeaders;
			else if(currSuffix == "diagonal-averages")
				action = Action::DiagonalAverages;
			else if(currSuffix == "plot-diagonal-averages")
				action = Action::PlotDiagonalAverages;
			else
			{
				std::cerr << "error: invalid action: " << currSuffix << "\n";
				std::exit(1);
			}
		}
		else if(currPrefix == "--base"  ||  currPrefix == "--prime-input-base")
		{
			bool baseAlphabetGiven = false;
			bool isBase = (currPrefix == "--base");
			int& thisBase = (isBase ? base : primeInputBase);
			std::string& thisBaseAlphabet = (isBase ? baseAlphabet : primeInputBaseAlphabet);
		
			if(currSuffix.find(",") != std::string::npos)
			{
				thisBaseAlphabet = currSuffix.substr(currSuffix.find(",") + 1, currSuffix.size() - 1);
				baseAlphabetGiven = true;
				currSuffix = currSuffix.substr(0, currSuffix.find(","));
			}
		
			try
				{ thisBase = std::stoi(currSuffix); }
			catch(...)
			{
				std::cerr << "error: invalid " << (isBase ? "" : "prime input ") << "base: " << currSuffix << "\n";
				std::exit(1);
			}
			if(!baseAlphabetGiven)
			{
				if(thisBase > 36)
				{
					baseAlphabetPending = 1 | (isBase ? 2 : 0);
				}
				else
				{
					thisBaseAlphabet = "";
					for(int i=0; i<thisBase; i++)
						thisBaseAlphabet.push_back(i<=9 ? '0'+i : 'A'+i-10);
				}
			}
			
			if(!baseAlphabetPending)
			{
				if(thisBase < 2)
				{
					std::cerr << "error: " << (isBase ? "" : "prime input ") << "base must not be lower than 2\n";
					std::exit(1);
				}
				if(baseAlphabetGiven  &&  thisBaseAlphabet.size() != (std::size_t)thisBase)
				{
					std::cerr << "error: length of " << (isBase ? "" : "prime input ") << "base alphabet has to equal " << (isBase ? "" : "prime input ") << "base\n";
					std::exit(1);
				}
			}
		}
		else if(currPrefix == "--limit")
		{
			long factor = -1;
			
			switch(currSuffix.back())
			{
				case 'K' : factor = 1000L; break;
				case 'M' : factor = 1000000L; break;
				case 'G' : factor = 1000000000L; break;
				case 'T' : factor = 1000000000000L; break;
			}
			
			if(factor != -1)
				currSuffix.pop_back();
			try
				{ limit = std::stol(currSuffix); }
			catch(...)
			{
				std::cerr << "error: invalid limit: " << currSuffix << "\n";
				std::exit(1);
			}
			if(factor != -1)
				limit *= factor;
			if(limit < 0)
			{
				//TODO: actually check integer overflow
				std::cerr << "error: limit must not be lower than 0 (if the value you specified is greater than 2^" << sizeof(long)*8-1 << "-1, this is because of an integer overflow)\n";
				std::exit(1);
			}
		}
		else if(currPrefix == "--output")
		{
			outputFile.open(currSuffix, std::ios::out);
			if(!outputFile)
			{
				std::cerr << "error: unable to open output file \"" << currSuffix << "\": " << strerror(errno) << "\n";
				std::exit(1);
			}
			outputBuf = outputFile.rdbuf();
		}
		else if(currPrefix == "--prime-input")
		{
			if(currSuffix.find(",") != std::string::npos)
			{
				std::string primeInputFilenameStr = currSuffix.substr(0, currSuffix.find(","));
				std::string primeInputBeginIndexStr = currSuffix.substr(currSuffix.find(",") + 1, currSuffix.size() - 1);
				currSuffix = primeInputFilenameStr;
				try
				{
					if((primeInputBeginIndex = std::stoi(primeInputBeginIndexStr)) < 0)
						throw -1;
				}
				catch(...)
				{
					std::cerr << "error: invalid prime input begin index: " << primeInputBeginIndexStr << "\n";
					std::exit(1);
				}
			}
		
			primeInput.open(currSuffix, std::ios::in);
			if(!primeInput)
			{
				std::cerr << "error: unable to open prime input file \"" << currSuffix << "\": " << strerror(errno) << "\n";
				std::exit(1);
			}
		}
		/*else if(currPrefix == "--hide-progress")
		{
			if(currSuffix.size() > 0  &&  (currSuffix[0] == 'n'  ||  currSuffix[0] == '0'))
				hideProgress = false;
		}*/
		else if(currPrefix == "--row-interval"  ||  currPrefix == "--column-interval")
		{
			bool isRow = (currPrefix == "--row-interval");
			std::string beginStr, intervalStr;
		
			if(currSuffix.find(",") == std::string::npos)
			{
				std::cerr << "error: malformed " << (isRow?"row":"column") << " interval: " << currSuffix << "\n";
				std::exit(1);
			}
			beginStr = currSuffix.substr(0, currSuffix.find(","));
			intervalStr = currSuffix.substr(currSuffix.find(",") + 1, currSuffix.size() - 1);
			
			try
			{
				if(((isRow ? rowBegin : columnBegin) = std::stoi(beginStr)) < 0)
					throw -1;
			}
			catch(...)
			{
				std::cerr << "error: invalid " << (isRow?"row":"column") << " interval begin value: " << beginStr << "\n";
				std::exit(1);
			}
			
			try
			{
				if(((isRow ? rowInterval : columnInterval) = std::stoi(intervalStr)) < 1)
					throw -1;
			}
			catch(...)
			{
				std::cerr << "error: invalid " << (isRow?"row":"column") << " interval interval value: " << intervalStr << "\n";
				std::exit(1);
			}
		}
		else if(currPrefix == "--enable-ascii-art-colors")
		{
			if(currSuffix.size() > 0  &&  (currSuffix[0] == 'y'  ||  currSuffix[0] == '1'))
				enableAsciiArtColors = true;
		}
		/*else if(currPrefix == "--generator-threads")
		{
			try
				{ numGeneratorThreads = std::stoi(currSuffix); }
			catch(...)
			{
				std::cerr << "error: invalid number of prime generator threads: " << currSuffix << "\n";
				std::exit(1);
			}
			
			if(numGeneratorThreads < 1)
			{
				std::cerr << "error: number of prime generator threads must not be lower than 1\n";
				std::exit(1);
			}
		}*/
		else if(currPrefix == "--terminal-size")
		{
			std::string widthStr, heightStr;
		
			if(currSuffix.find(",") == std::string::npos)
			{
				std::cerr << "error: malformed terminal size: " << currSuffix << "\n";
				std::exit(1);
			}
			
			widthStr = currSuffix.substr(0, currSuffix.find(","));
			heightStr = currSuffix.substr(currSuffix.find(",") + 1, currSuffix.size() - 1);
			
			try
				{ terminalWidth = stoi(widthStr); }
			catch(...)
			{
				std::cerr << "error: invalid terminal width: " << widthStr << "\n";
				std::exit(1);
			}
			
			try
				{ terminalHeight = stoi(heightStr); }
			catch(...)
			{
				std::cerr << "error: invalid terminal height: " << heightStr << "\n";
				std::exit(1);
			}
			
			if(terminalWidth <= 0  ||  terminalHeight <= 0)
			{
				std::cerr << "error: terminal " << (terminalWidth<=0 ? "width" : "height") << " must not be less than 1\n";
				std::exit(1);
			}
		}
		else
		{
			std::cerr << "error: unknown option: " << currPrefix << "\n";
			std::exit(1);
		}
	}
	
	if(action == Action::Invalid)
	{
		std::cerr << "error: required option --action not given\n";
		std::exit(1);
	}
	if(limit == -1)
	{
		std::cerr << "error: required option --limit not given\n";
		std::exit(1);
	}
	if(action == Action::Generate  &&  baseAlphabetPending)
	{
		std::cerr << "error: cannot properly generate an alphabet for " << (baseAlphabetPending>1 ? "" : "prime input ") << "bases greater than 36, please specify one yourself\n";
		std::exit(1);
	}
	if(action == Action::PlotDiagonalAverages  &&  !terminalSizeOptional  &&  (terminalWidth <= 0  ||  terminalHeight <= 0))
	{
		std::cerr << "error: with the current action on this operating system, you have to specifiy the terminal size\n";
		std::exit(1);
	}
	
	//if(action == Action::Generate  &&  primeInput.is_open())
	//	std::cerr << "warning: prime input file ignored, because \"generate\" action is specified\n";
}
